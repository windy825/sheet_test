
# -*- coding: utf-8 -*-
"""
streamlit_app.py
Î°úÏª¨/ÌÅ¥ÎùºÏö∞Îìú Í≥µÏö©: ÏÑ†Ïàò¬∑ÏÑ†Í∏âÍ∏à Îß§Ïπ≠ & ÎåÄÏãúÎ≥¥Îìú (ÏïàÏ†ÑÍ∞ÄÎìú Í∞ïÌôîÌåê)

Ï£ºÏöî Í∞úÏÑ†
- Îç∞Ïù¥ÌÑ∞ ÎØ∏Î°úÎî©/Îπà Îç∞Ïù¥ÌÑ∞ÌîÑÎ†àÏûÑÏùº ÎïåÏóêÎèÑ Ïï±Ïù¥ Ï£ΩÏßÄ ÏïäÍ≥† ÏïàÎÇ¥Î¨∏ ÌëúÏãú
- Ï†êÏàò ÌõÑÎ≥¥Í∞Ä ÏóÜÏùÑ Îïå 'Ï¥ùÏ†ê' Ï†ïÎ†¨ÏóêÏÑú KeyError ÎÇòÎäî Î¨∏Ï†ú Î∞©ÏßÄ
- Í∏àÏï° Î≥ÄÌôòÏùÄ ÏßÄÏ†ï Ïª¨Îüº(Ï†ÑÌëúÌÜµÌôîÏï°/ÌòÑÏßÄÌÜµÌôîÏï°)Îßå ÎåÄÏÉÅÏúºÎ°ú ÏïàÏ†Ñ Ï≤òÎ¶¨
- ÏãúÌä∏Î™Ö/Ïª¨ÎüºÎ™Ö Í∞úÌñâ¬∑Í≥µÎ∞± Ï†ïÍ∑úÌôî

Ïã§Ìñâ Î∞©Î≤ï(Î°úÏª¨):
    pip install -r requirements.txt
    streamlit run streamlit_app.py
"""
from __future__ import annotations

import math
from datetime import datetime
from difflib import SequenceMatcher
from typing import Dict, Optional, Tuple, List

import altair as alt
import numpy as np
import pandas as pd
import streamlit as st

# -----------------------------
# Í∏∞Î≥∏ ÏÑ§Ï†ï
# -----------------------------
st.set_page_config(page_title="ÏÑ†Ïàò¬∑ÏÑ†Í∏âÍ∏à Îß§Ïπ≠ & ÎåÄÏãúÎ≥¥Îìú", layout="wide", page_icon="üìä")

DEFAULT_EXCEL_PATH = "./2025.07ÏõîÎßê ÏÑ†ÏàòÏÑ†Í∏âÍ∏à ÌòÑÌô©_20250811.xlsx"  # Î°úÏª¨ÏóêÏÑú ÎèôÏùº Ìè¥ÎçîÏóê Îëò Í≤ΩÏö∞ ÏûêÎèô Î°úÎìú ÏãúÎèÑ

# -----------------------------
# Ïú†Ìã∏
# -----------------------------
def norm_col(c: str) -> str:
    if not isinstance(c, str):
        return c
    return (
        c.replace("\\n", "")
         .replace("\n", "")
         .replace("\r", "")
         .replace(" ", "")
         .strip()
    )

def normalize_text(s: Optional[str]) -> str:
    if s is None or (isinstance(s, float) and math.isnan(s)):
        return ""
    return "".join(ch for ch in str(s).upper().strip())

def text_sim(a: Optional[str], b: Optional[str]) -> float:
    a, b = normalize_text(a), normalize_text(b)
    if not a or not b:
        return 0.0
    return SequenceMatcher(None, a, b).ratio()

def to_number(x) -> Optional[float]:
    try:
        if pd.isna(x):
            return None
        if isinstance(x, str):
            x = x.replace(",", "").replace(" ", "")
        v = float(x)
        if math.isfinite(v):
            return v
        return None
    except Exception:
        return None

def choose_amount_row(row: pd.Series) -> Optional[float]:
    # Í∏àÏï° Ïö∞ÏÑ†ÏàúÏúÑ: Ï†ÑÌëúÌÜµÌôîÏï° -> ÌòÑÏßÄÌÜµÌôîÏï°
    for key in ["Ï†ÑÌëúÌÜµÌôîÏï°", "ÌòÑÏßÄÌÜµÌôîÏï°"]:
        if key in row.index:
            v = to_number(row[key])
            if v is not None:
                return v
    return None

def to_date(x) -> Optional[pd.Timestamp]:
    try:
        if pd.isna(x):
            return None
        return pd.to_datetime(x)
    except Exception:
        return None

def ensure_keycols(df: pd.DataFrame) -> pd.DataFrame:
    # ÏûêÏ£º Ïì∞Îäî Í∞úÌñâ Ìè¨Ìï® Ïª¨ÎüºÏùÑ Îã®Ïùº ÌÇ§Î°ú ÌÜµÏùº
    mapping = {
        "Ï†ïÏÇ∞\nÏÑ†ÏàòÍ∏à\nÍ≥†Ïú†Î≤àÌò∏": "Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏",
        "Ï†ïÏÇ∞Ïó¨Î∂Ä\n(O/X)": "Ï†ïÏÇ∞Ïó¨Î∂Ä",
        "Í≥†Í∞ùÎ™Ö\n(ÎìúÎ°≠Îã§Ïö¥)": "Í≥†Í∞ùÎ™Ö",
        "ÌöåÏàòÎ™©ÌëúÏùºÏ†ï\n(YY/MM)": "ÌöåÏàòÎ™©ÌëúÏùºÏ†ï(YY/MM)",
        "Í≤ΩÍ≥ºÍ∏∞Í∞Ñ\n(Í∞úÏõî)": "Í≤ΩÍ≥ºÍ∏∞Í∞Ñ(Í∞úÏõî)",
    }
    for old, new in mapping.items():
        if old in df.columns and new not in df.columns:
            df.rename(columns={old: new}, inplace=True)
    return df

# -----------------------------
# Îç∞Ïù¥ÌÑ∞ Î°úÎìú
# -----------------------------
@st.cache_data(show_spinner=False)
def load_excel(excel_bytes_or_path) -> Dict[str, pd.DataFrame]:
    if excel_bytes_or_path is None:
        return {}
    xls = pd.ExcelFile(excel_bytes_or_path)
    sheets = {}
    for s in xls.sheet_names:
        df = pd.read_excel(xls, sheet_name=s)
        df.columns = [norm_col(c) for c in df.columns]
        df = df.dropna(how="all")
        sheets[s] = ensure_keycols(df)
    return sheets

def find_sheet(sheets: Dict[str, pd.DataFrame], target: str) -> Optional[str]:
    target_norm = normalize_text(target)
    for name in sheets.keys():
        if normalize_text(name) == target_norm:
            return name
    for name in sheets.keys():
        if target_norm in normalize_text(name):
            return name
    return None

# -----------------------------
# Îß§Ïπ≠ Ï†êÏàò
# -----------------------------
def calc_match_score(sunsu: pd.Series, seongeup: pd.Series,
                     today: datetime, date_half_life_days: int = 90) -> Tuple[float, Dict[str, float]]:
    weights = {"linked_id": 60.0, "contract": 20.0, "name": 10.0, "date": 5.0, "text": 5.0, "amount": 10.0}

    def get(row: pd.Series, key: str) -> Optional[str]:
        return row.get(key) if key in row.index else None

    linked = 0.0
    seon_link = get(seongeup, "Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏") or get(seongeup, "Ï†ïÏÇ∞\nÏÑ†ÏàòÍ∏à\nÍ≥†Ïú†Î≤àÌò∏")
    sun_id = get(sunsu, "Í≥†Ïú†ÎÑòÎ≤Ñ")
    if seon_link and sun_id and str(seon_link).strip() == str(sun_id).strip():
        linked = 1.0

    contract_equal = 0.0
    if get(sunsu, "Í≥ÑÏïΩÎ≤àÌò∏") and get(seongeup, "Í≥ÑÏïΩÎ≤àÌò∏"):
        if str(get(sunsu, "Í≥ÑÏïΩÎ≤àÌò∏")).strip() == str(get(seongeup, "Í≥ÑÏïΩÎ≤àÌò∏")).strip():
            contract_equal = 1.0

    name_sim = text_sim(get(sunsu, "ÏóÖÏ≤¥Î™Ö"), get(seongeup, "ÏóÖÏ≤¥Î™Ö"))

    d1 = to_date(get(sunsu, "Ï†ÑÍ∏∞Ïùº"))
    d2 = to_date(get(seongeup, "Ï†ÑÍ∏∞Ïùº"))
    date_score = 0.0
    if d1 is not None and d2 is not None:
        dd = abs((d1 - d2).days)
        date_score = 0.5 ** (dd / float(max(date_half_life_days, 1)))

    text_contains = 0.0
    if get(seongeup, "ÌÖçÏä§Ìä∏") and get(sunsu, "Í≥ÑÏïΩÎ≤àÌò∏"):
        if str(get(sunsu, "Í≥ÑÏïΩÎ≤àÌò∏")).strip() in str(get(seongeup, "ÌÖçÏä§Ìä∏")):
            text_contains = 1.0

    amt_sun = choose_amount_row(sunsu)
    amt_seon = choose_amount_row(seongeup)
    amount_score = 0.0
    if amt_sun is not None and amt_seon is not None and amt_sun != 0:
        diff = abs(amt_sun - amt_seon)
        amount_score = max(0.0, 1.0 - (diff / abs(amt_sun)))

    parts = {
        "linked_id": linked * weights["linked_id"],
        "contract": contract_equal * weights["contract"],
        "name": name_sim * weights["name"],
        "date": date_score * weights["date"],
        "text": text_contains * weights["text"],
        "amount": amount_score * weights["amount"],
    }
    total = sum(parts.values())
    return total, parts

# -----------------------------
# UI: Îç∞Ïù¥ÌÑ∞ ÏóÖÎ°úÎìú/Î°úÎìú
# -----------------------------
st.sidebar.header("Îç∞Ïù¥ÌÑ∞")
excel_file = st.sidebar.file_uploader("ÏóëÏÖÄ ÏóÖÎ°úÎìú (.xlsx)", type=["xlsx"], accept_multiple_files=False)

default_used = False
sheets = {}
if excel_file is not None:
    sheets = load_excel(excel_file)
else:
    try:
        with open(DEFAULT_EXCEL_PATH, "rb") as f:
            sheets = load_excel(f)
            default_used = True
            st.sidebar.info("Í∏∞Î≥∏ Í≤ΩÎ°úÏóêÏÑú ÏóëÏÖÄÏùÑ Î∂àÎü¨ÏôîÏäµÎãàÎã§.")
    except Exception:
        st.sidebar.warning("ÏóëÏÖÄÏùÑ ÏóÖÎ°úÎìúÌïòÍ±∞ÎÇò, Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨Ïóê ÏóëÏÖÄÏùÑ Ìè¨Ìï®ÏãúÏºú Ï£ºÏÑ∏Ïöî.")

if not sheets:
    st.info("Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÏÑú Í∏∞Îä•ÏùÑ ÎπÑÌôúÏÑ±ÌôîÌï©ÎãàÎã§. ÏôºÏ™Ω ÏÇ¨Ïù¥ÎìúÎ∞îÏóêÏÑú ÏóëÏÖÄÏùÑ ÏóÖÎ°úÎìúÌïòÎ©¥ Î™®Îì† Í∏∞Îä•Ïù¥ ÏºúÏßëÎãàÎã§.")
    st.stop()

s_sunsu = find_sheet(sheets, "ÏÑ†ÏàòÍ∏à")
s_seon = find_sheet(sheets, "ÏÑ†Í∏âÍ∏à")
if s_sunsu is None or s_seon is None:
    st.error("ÏãúÌä∏ Ïù¥Î¶Ñ 'ÏÑ†ÏàòÍ∏à'Í≥º 'ÏÑ†Í∏âÍ∏à'ÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§. ÏóëÏÖÄ ÏãúÌä∏Î™ÖÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
    st.stop()

df_sunsu = sheets[s_sunsu].copy()
df_seon = sheets[s_seon].copy()

# Í∏àÏï°/ÏùºÏûê ÌååÏÉù
for df in (df_sunsu, df_seon):
    if "Í∏àÏï°" not in df.columns:
        df["Í∏àÏï°"] = df.apply(choose_amount_row, axis=1)
    if "Ï†ÑÍ∏∞Ïùº" in df.columns:
        df["Ï†ÑÍ∏∞Ïùº_parsed"] = pd.to_datetime(df["Ï†ÑÍ∏∞Ïùº"], errors="coerce")

# -----------------------------
# Îß§Ïπ≠ ÏòµÏÖò
# -----------------------------
st.sidebar.header("Îß§Ïπ≠ ÏòµÏÖò")
date_half_life_days = st.sidebar.slider("ÏùºÏûê Í∑ºÏ†ëÎèÑ Ï†àÎ∞òÍ∞êÏá†Ïùº(Ïùº)", 15, 180, 90, 15)
score_threshold = st.sidebar.slider("ÌõÑÎ≥¥ ÌëúÏãú ÏµúÏÜåÏ†êÏàò", 0, 100, 40, 5)

# -----------------------------
# ÌÉ≠
# -----------------------------
tab1, tab2, tab3 = st.tabs(["üîé Îß§Ïπ≠ Ï°∞Ìöå", "‚öôÔ∏è ÏùºÍ¥Ñ Îß§Ïπ≠ Ï†úÏïà", "üìä ÎåÄÏãúÎ≥¥Îìú"])

with tab1:
    st.subheader("ÌäπÏ†ï ÏÑ†ÏàòÍ∏àÍ≥º Îß§Ïπ≠ÎêòÎäî ÏÑ†Í∏âÍ∏à ÌõÑÎ≥¥ Ï°∞Ìöå")

    if df_sunsu.empty or df_seon.empty:
        st.warning("ÏÑ†ÏàòÍ∏à/ÏÑ†Í∏âÍ∏à Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§. ÏóÖÎ°úÎìú ÌååÏùºÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
        st.stop()

    def sunsu_label(row: pd.Series) -> str:
        gid = str(row.get("Í≥†Ïú†ÎÑòÎ≤Ñ", ""))
        comp = str(row.get("ÏóÖÏ≤¥Î™Ö", ""))
        contract = str(row.get("Í≥ÑÏïΩÎ≤àÌò∏", ""))
        date = row.get("Ï†ÑÍ∏∞Ïùº_parsed", row.get("Ï†ÑÍ∏∞Ïùº", ""))
        amt = row.get("Í∏àÏï°", None)
        amt_str = f"{amt:,.0f}" if isinstance(amt, (int, float, np.number)) and not pd.isna(amt) else "-"
        dstr = date.strftime("%Y-%m-%d") if isinstance(date, pd.Timestamp) else (str(date) if date is not None else "")
        return f"[{gid}] {comp} | Í≥ÑÏïΩ:{contract} | ÏùºÏûê:{dstr} | Í∏àÏï°:{amt_str}"

    sunsu_options = df_sunsu.index.tolist()
    if not sunsu_options:
        st.info("ÏÑ†ÏàòÍ∏à ÌñâÏù¥ ÏóÜÏäµÎãàÎã§.")
        st.stop()

    selectable = [(i, sunsu_label(df_sunsu.loc[i])) for i in sunsu_options]
    selected_idx = st.selectbox("ÏÑ†ÏàòÍ∏à ÏÑ†ÌÉù", options=[i for i, _ in selectable], format_func=lambda i: dict(selectable)[i])

    if selected_idx is None:
        st.info("ÏÑ†ÏàòÍ∏àÏùÑ ÏÑ†ÌÉùÌïòÎ©¥ ÌõÑÎ≥¥Í∞Ä ÌëúÏãúÎê©ÎãàÎã§.")
    else:
        target_row = df_sunsu.loc[selected_idx]
        today = datetime.now()

        # Îã®Ïùº ÌõÑÎ≥¥ Ï†êÏàò Í≥ÑÏÇ∞
        scores: List[dict] = []
        for i, row in df_seon.iterrows():
            total, parts = calc_match_score(target_row, row, today=today, date_half_life_days=date_half_life_days)
            if total >= score_threshold:
                scores.append({
                    "ÏÑ†Í∏â_index": i,
                    "Ï¥ùÏ†ê": round(total, 2),
                    **{f"Ï†êÏàò:{k}": round(v, 2) for k, v in parts.items()},
                    "Í≥ÑÏïΩÎ≤àÌò∏": row.get("Í≥ÑÏïΩÎ≤àÌò∏"),
                    "ÏóÖÏ≤¥Î™Ö": row.get("ÏóÖÏ≤¥Î™Ö"),
                    "Ï†ÑÍ∏∞Ïùº": row.get("Ï†ÑÍ∏∞Ïùº_parsed", row.get("Ï†ÑÍ∏∞Ïùº")),
                    "Í∏àÏï°": row.get("Í∏àÏï°"),
                    "Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏": row.get("Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏"),
                    "ÌÖçÏä§Ìä∏": row.get("ÌÖçÏä§Ìä∏"),
                    "Í≥†Ïú†ÎÑòÎ≤Ñ": row.get("Í≥†Ïú†ÎÑòÎ≤Ñ"),
                })

        if not scores:
            st.info("Ï†êÏàò ÏûÑÍ≥ÑÍ∞íÏùÑ ÎÇÆÏ∂îÍ±∞ÎÇò, ÏóÖÎ°úÎìú Îç∞Ïù¥ÌÑ∞(Í∏àÏï°/Í≥ÑÏïΩÎ≤àÌò∏/ÏùºÏûê/ÏóÖÏ≤¥Î™Ö) Ïª¨ÎüºÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî. ÌòÑÏû¨ Ï°∞Í±¥Ïóê Î∂ÄÌï©ÌïòÎäî ÌõÑÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.")
        else:
            cand_df = pd.DataFrame(scores)
            # ÏïàÏ†Ñ Ï†ïÎ†¨
            if "Ï¥ùÏ†ê" in cand_df.columns:
                cand_df = cand_df.sort_values(by=["Ï¥ùÏ†ê"], ascending=False).reset_index(drop=True)
            st.markdown("**Îã®Ïùº Ìï≠Î™© ÌõÑÎ≥¥(Ï†êÏàò Ïàú)**")
            st.dataframe(cand_df, use_container_width=True, height=420)

with tab2:
    st.subheader("ÏùºÍ¥Ñ Îß§Ïπ≠ Ï†úÏïà(Top-1 Îã®Ïùº ÌõÑÎ≥¥)")

    if df_sunsu.empty or df_seon.empty:
        st.info("Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ ÏûàÏñ¥ ÏùºÍ¥Ñ Ï†úÏïàÏùÑ ÏÉùÎûµÌï©ÎãàÎã§.")
    else:
        max_rows = st.number_input("ÎåÄÏÉÅ ÏÑ†ÏàòÍ∏à Ïàò(ÏÉÅÏúÑ NÌñâ)", 10, max(10, len(df_sunsu)), min(200, len(df_sunsu)), 10)
        today = datetime.now()
        batch_rows = []

        sunsu_iter = df_sunsu.head(int(max_rows))
        for si, srow in sunsu_iter.iterrows():
            best_score = -1.0
            best_idx = None
            for ei, erow in df_seon.iterrows():
                total, _ = calc_match_score(srow, erow, today=today, date_half_life_days=date_half_life_days)
                if total > best_score:
                    best_score = total
                    best_idx = ei
            if best_idx is not None and best_score >= score_threshold:
                erow = df_seon.loc[best_idx]
                batch_rows.append({
                    "ÏÑ†Ïàò_index": si,
                    "ÏÑ†Í∏â_index": best_idx,
                    "Ï¥ùÏ†ê": round(best_score, 2),
                    "ÏÑ†Ïàò_Í≥†Ïú†ÎÑòÎ≤Ñ": srow.get("Í≥†Ïú†ÎÑòÎ≤Ñ"),
                    "ÏÑ†Ïàò_Í≥ÑÏïΩÎ≤àÌò∏": srow.get("Í≥ÑÏïΩÎ≤àÌò∏"),
                    "ÏÑ†Ïàò_ÏóÖÏ≤¥Î™Ö": srow.get("ÏóÖÏ≤¥Î™Ö"),
                    "ÏÑ†Ïàò_Ï†ÑÍ∏∞Ïùº": srow.get("Ï†ÑÍ∏∞Ïùº_parsed", srow.get("Ï†ÑÍ∏∞Ïùº")),
                    "ÏÑ†Ïàò_Í∏àÏï°": srow.get("Í∏àÏï°"),
                    "ÏÑ†Í∏â_Í≥†Ïú†ÎÑòÎ≤Ñ": erow.get("Í≥†Ïú†ÎÑòÎ≤Ñ"),
                    "ÏÑ†Í∏â_Í≥ÑÏïΩÎ≤àÌò∏": erow.get("Í≥ÑÏïΩÎ≤àÌò∏"),
                    "ÏÑ†Í∏â_ÏóÖÏ≤¥Î™Ö": erow.get("ÏóÖÏ≤¥Î™Ö"),
                    "ÏÑ†Í∏â_Ï†ÑÍ∏∞Ïùº": erow.get("Ï†ÑÍ∏∞Ïùº_parsed", erow.get("Ï†ÑÍ∏∞Ïùº")),
                    "ÏÑ†Í∏â_Í∏àÏï°": erow.get("Í∏àÏï°"),
                    "ÏÑ†Í∏â_Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏": erow.get("Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏"),
                })

        if not batch_rows:
            st.info("Ï†úÏïà Í∞ÄÎä•Ìïú Îß§Ïπ≠Ïù¥ ÏóÜÏäµÎãàÎã§. Ï†êÏàò ÏûÑÍ≥ÑÍ∞íÏùÑ ÎÇÆÏ∂∞Î≥¥ÏÑ∏Ïöî.")
        else:
            batch_df = pd.DataFrame(batch_rows).sort_values(by="Ï¥ùÏ†ê", ascending=False).reset_index(drop=True)
            st.dataframe(batch_df, use_container_width=True, height=450)
            csv = batch_df.to_csv(index=False).encode("utf-8-sig")
            st.download_button("ÏùºÍ¥Ñ Ï†úÏïà CSV Îã§Ïö¥Î°úÎìú", data=csv, file_name="batch_match_suggestions.csv", mime="text/csv")

with tab3:
    st.subheader("ÏöîÏïΩ ÏßÄÌëú & ÏãúÍ∞ÅÌôî")

    def is_matched_row(df: pd.DataFrame) -> pd.Series:
        cond = pd.Series(False, index=df.index)
        if "Ï†ïÏÇ∞Ïó¨Î∂Ä" in df.columns:
            cond = cond | df["Ï†ïÏÇ∞Ïó¨Î∂Ä"].astype(str).str.contains("O", na=False)
        if "Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏" in df.columns:
            cond = cond | df["Ï†ïÏÇ∞ÏÑ†ÏàòÍ∏àÍ≥†Ïú†Î≤àÌò∏"].astype(str).str.strip().ne("")
        return cond

    if df_sunsu.empty and df_seon.empty:
        st.info("ÎåÄÏãúÎ≥¥ÎìúÎ•º Î†åÎçîÎßÅÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
    else:
        sunsu_matched = is_matched_row(df_sunsu) if not df_sunsu.empty else pd.Series([], dtype=bool)
        seon_matched = is_matched_row(df_seon) if not df_seon.empty else pd.Series([], dtype=bool)

        kpi = st.columns(4)
        with kpi[0]:
            st.metric("ÏÑ†ÏàòÍ∏à Í±¥Ïàò", f"{len(df_sunsu):,}")
        with kpi[1]:
            st.metric("ÏÑ†ÏàòÍ∏à ÎØ∏Ï†ïÏÇ∞ Í±¥Ïàò", f"{int((~sunsu_matched).sum()) if len(sunsu_matched) else 0:,}")
        with kpi[2]:
            st.metric("ÏÑ†Í∏âÍ∏à Í±¥Ïàò", f"{len(df_seon):,}")
        with kpi[3]:
            st.metric("ÏÑ†Í∏âÍ∏à ÎØ∏Ï†ïÏÇ∞ Í±¥Ïàò", f"{int((~seon_matched).sum()) if len(seon_matched) else 0:,}")

        def to_amt_df(df: pd.DataFrame) -> pd.DataFrame:
            base = df.copy()
            base["Í∏àÏï°"] = base["Í∏àÏï°"].apply(to_number)
            return base.dropna(subset=["Í∏àÏï°"])

        def group_unsettled(df: pd.DataFrame, title: str):
            if df.empty:
                st.info(f"{title}: Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return
            base = df.copy()
            m = is_matched_row(base)
            base = base[~m]
            base = to_amt_df(base)
            if base.empty:
                st.info(f"{title}: ÎØ∏Ï†ïÏÇ∞ Ìï≠Î™© ÏóÜÏùå")
                return
            agg = base.groupby("ÏóÖÏ≤¥Î™Ö", dropna=False)["Í∏àÏï°"].sum().reset_index().sort_values(by="Í∏àÏï°", ascending=False).head(20)
            chart = alt.Chart(agg.dropna()).mark_bar().encode(
                x=alt.X("Í∏àÏï°:Q", title="Í∏àÏï° Ìï©Í≥Ñ"),
                y=alt.Y("ÏóÖÏ≤¥Î™Ö:N", sort="-x", title="ÏóÖÏ≤¥Î™Ö")
            ).properties(height=360)
            st.markdown(f"**{title} - ÎØ∏Ï†ïÏÇ∞ Í∏àÏï° ÏÉÅÏúÑ 20 ÏóÖÏ≤¥**")
            st.altair_chart(chart, use_container_width=True)
            st.dataframe(agg, use_container_width=True, height=260)

        c1, c2 = st.columns(2)
        with c1: group_unsettled(df_sunsu, "ÏÑ†ÏàòÍ∏à")
        with c2: group_unsettled(df_seon, "ÏÑ†Í∏âÍ∏à")

        def aging_chart(df: pd.DataFrame, title: str):
            col = "Í≤ΩÍ≥ºÍ∏∞Í∞Ñ(Í∞úÏõî)" if "Í≤ΩÍ≥ºÍ∏∞Í∞Ñ(Í∞úÏõî)" in df.columns else None
            if df.empty or col is None:
                st.info(f"{title}: 'Í≤ΩÍ≥ºÍ∏∞Í∞Ñ(Í∞úÏõî)' Ïª¨ÎüºÏù¥ ÏóÜÏñ¥ ÏóêÏù¥Ïßï Ï∞®Ìä∏Î•º ÏÉùÎûµÌï©ÎãàÎã§.")
                return
            base = to_amt_df(df)
            if base.empty:
                st.info(f"{title}: Í∏àÏï° Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return
            def bucket(x):
                try:
                    v = float(x)
                except Exception:
                    return "ÎØ∏ÏÉÅ"
                if v < 1: return "0-1Í∞úÏõî"
                if v < 3: return "1-3Í∞úÏõî"
                if v < 6: return "3-6Í∞úÏõî"
                if v < 12: return "6-12Í∞úÏõî"
                if v < 24: return "12-24Í∞úÏõî"
                return "24Í∞úÏõî+"
            base["Î≤ÑÌÇ∑"] = base[col].apply(bucket)
            agg = base.groupby("Î≤ÑÌÇ∑")["Í∏àÏï°"].sum().reset_index()
            order = ["0-1Í∞úÏõî", "1-3Í∞úÏõî", "3-6Í∞úÏõî", "6-12Í∞úÏõî", "12-24Í∞úÏõî", "24Í∞úÏõî+"]
            agg["Î≤ÑÌÇ∑"] = pd.Categorical(agg["Î≤ÑÌÇ∑"], categories=order, ordered=True)
            agg = agg.sort_values("Î≤ÑÌÇ∑")
            chart = alt.Chart(agg).mark_bar().encode(
                x=alt.X("Î≤ÑÌÇ∑:N", sort=order, title="Í≤ΩÍ≥ºÍ∏∞Í∞Ñ Î≤ÑÌÇ∑"),
                y=alt.Y("Í∏àÏï°:Q", title="Í∏àÏï° Ìï©Í≥Ñ")
            ).properties(height=300)
            st.markdown(f"**{title} - ÏóêÏù¥Ïßï(Í∞úÏõî) Î∂ÑÌè¨**")
            st.altair_chart(chart, use_container_width=True)
            st.dataframe(agg, use_container_width=True, height=240)

        c3, c4 = st.columns(2)
        with c3: aging_chart(df_sunsu, "ÏÑ†ÏàòÍ∏à")
        with c4: aging_chart(df_seon, "ÏÑ†Í∏âÍ∏à")

st.caption("‚ìò Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ ÏûàÍ±∞ÎÇò ÌõÑÎ≥¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ÏóêÎèÑ Ïò§Î•ò ÏóÜÏù¥ ÏïàÎÇ¥ Î©îÏãúÏßÄÎßå ÌëúÏãúÎêòÎèÑÎ°ù Î≥¥Í∞ïÌñàÏäµÎãàÎã§.")
